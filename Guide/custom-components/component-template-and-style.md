---
title: "Component Template and Style"
slug: "component-template-and-style"
excerpt: "This section explains the concept of component template and style."
hidden: false
metadata: 
  image: []
  robots: "index"
createdAt: "Tue May 02 2023 07:38:17 GMT+0000 (Coordinated Universal Time)"
updatedAt: "Fri Jun 09 2023 07:06:59 GMT+0000 (Coordinated Universal Time)"
layout: "default"
parent: "Custom Components"
grand_parent: "Guide"
---
# Component Template and Style 
*** 
Just like pages, custom components have their own `wxml` templates and `wxss` styles.

## Component Template

Component templates are written in the same way as page templates. The node tree generated by the combination of the component template and component data will be inserted into the reference position of the component.

A `<slot>` node can be provided in the component template to host the child nodes provided via component reference.

### Code example:

```xml
<!--WXML-->
{% raw %}
<!-- Component template -->
<view class="wrapper">
  <view>This indicates the internal node of the component</view>
  <slot></slot>
</view>
{% endraw %}
```

```xml
<!--WXML-->
{% raw %}
<!--Page template where the component is referenced-->
<view>
  <component-tag-name>
    <!-- This part is added to the location of the  <slot>  component -->
    <view>This is inserted in the slot component</view>
  </component-tag-name>
</view>
{% endraw %}
```

> ðŸ“˜ Note
> 
> The custom component referenced in the template and the name of its corresponding node should be explicitly defined in the `json` file, otherwise the node will be deemed as meaningless. Besides, the node name can also be declared as an [Abstract Node](doc:abstract-node).

## Template Data Binding

Like an ordinary WXML template, data binding can also be employed to pass dynamic data to child component properties.

## Code example:

```xml
<!--WXML-->
{% raw %}
<!--Page template where the component is referenced-->
<view>
  <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
    <!-- This part is added to the location of the  <slot>  component -->
    <view>This is inserted in the slot component</view>
  </component-tag-name>
</view>
{% endraw %}
```

In the above example, the component properties `propA` and `propB` receive data passed from the page, and the page can change linked data field via `setData`.

## slot of Component's WXML

The slot `node` can be included in the `wxml` of a component, which is used to sustain the `wxml` structure provided by the component user.

By default, there can be only one slot in the component's `wxml`. If you need to use multiple slots, you can declare and enable them in the component's `js`.

```javascript
Component({
  options: {
    multipleSlots: true // Enable multiple slots in the options of component definition.
  },
  properties: { /* ... */ },
  methods: { /* ... */ }
})
```

At this point, multiple slots can be used in the `wxml` of this component, which are distinguished by `name`.

```xml
<!--WXML-->
{% raw %}
<!-- Component template -->
<view class="wrapper">
  <slot name="before"></slot>
  <view>This indicates the internal details of the component</view>
  <slot name="after"></slot>
</view>
{% endraw %}
```

Use the `slot` attribute to insert nodes into different slots.

```xml
<!--WXML-->
{% raw %}
<!--Page template where the component is referenced-->
<view>
  <component-tag-name>
    <!-- This part is added to the location of the  <slot name="before">  component -->
    <view slot="before">This is inserted in the slot name="before" component</view>
    <!-- This part is added to the location of the  <slot name="after">  component -->
    <view slot="after">This is inserted in the slot name="after" component</view>
  </component-tag-name>
</view>
{% endraw %}
```

## Component Style

The component's style corresponding to the `wxss` file only takes effect for the nodes in the `wxml`. When writing component styles, pay attention to the following:

- Components and pages referencing components cannot use ID selector (`#a`), attribute selector (`[a]`), or tag name selector. Use class selector instead.
- The use of descendant selector (`.a .b`) in components and pages referencing components may have unexpected behaviours in extreme cases. If this happens, avoid using them.
- Sub-element selector (`.a>.b`) can only be used between the view component and its child nodes. Using it for other components may cause unexpected errors.
- Inherited styles such as `font` and `color` will be inherited from outside the component to inside the component.
- Except inherited styles, styles in `app.wxss` and styles of the page where a custom component is located don't take effect for the component.

```css WXSS
#a { } /* Cannot be used in components */
[a] { } /* Cannot be used in components */
button { } /* Cannot be used in components */
.a > .b { } /* Invalid unless  .a  is  view  component node */
```

Additionally, you can specify the default style for the node where the component is located by using the `:host`selector.

### Code example:

```css WXSS
/* Component custom-component.wxss */
:host {
  color: yellow;
}
```

```xml
<!--WXML-->
{% raw %}
<!-- Page's WXML -->
<custom-component>The text here is highlighted in yellow</custom-component>
{% endraw %}
```

## External Style Class

Sometimes, you want components to accept style classes passed in from outside. In this case, you can use the `externalClasses` definition section to define several external style classes in `Component`.

This feature can be used to implement the `hover-class` attribute similar to the `view` component: The page can provide a style class, which is assigned to the `hover-class` of `view` and is written in the page rather than the implementation of the `view` component.

> ðŸ“˜ Note
> 
> Avoid using an ordinary style class and an external style class on the same node because their priorities are not defined.

```javascript
/* Component custom-component.js */
Component({
  externalClasses: ['my-class']
})
```

```xml
<!--WXML-->
{% raw %}
<!-- Component custom-component.wxml -->
<custom-component class="my-class">The color of this text is determined by the  class  outside the component</custom-component>
{% endraw %}
```

Therefore, the component user can specify the class corresponding to this style class, just like using ordinary properties. From base library 2.7.1 and later, multiple corresponding classes can be specified.

### Code example:

```xml
<!--WXML-->
{% raw %}
<!-- Page's WXML -->
<custom-component my-class="red-text" />
<custom-component my-class="large-text" />
<!-- The following code is supported as of base library 2.7.1 -->
<custom-component my-class="red-text large-text" />
{% endraw %}
```

```css WXSS
.red-text {
  color: red;
}
.large-text {
  font-size: 1.5em;
}
```

## Making a component accept global styles

By default, the styles of a custom component are only affected by the custom component's `wxss`, except in the following two situations:

- Tag name selectors (or some other special selectors) are used in `app.wxss` or the page's `wxss` to specify styles directly. These selectors affect the page and all components. Normally, this is not recommended.
- The `addGlobalClass` option is activated on a specific custom component, which makes the custom component affected by all style definitions in `app.wxss` or the page's `wxss`.

To activate the `addGlobalClass` option, simply set the `options.addGlobalClass` field to true in the component constructor.

**Note: When the `addGlobalClass` option is activated, there is a risk of external styles contaminating component styles. You should exercise caution.**

```javascript
/* `custom-component.js` of the component */
Component({
  options: {
    addGlobalClass: true,
  }
})
```

```Text WXML
<!-- `custom-component.wxml` of the component -->
<text class="red-text">
  The color of this paragraph is determined by the styles defined in the `app.wxss` and the page's `wxss`.
</text>
```

```Text WXSS
/* app.wxss */
.red-text {
  color: red;
}
```
